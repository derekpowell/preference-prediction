---
title: "Untitled"
format: html
---

```{r}
library(tidyverse)
library(minpack.lm)
```

```{r echo=FALSE, include=FALSE}
library(themis)
library(tidyverse)
library(tidymodels)
library(tidyclust)
library(ggplot2)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE, include=FALSE}
library(themis)
library(tidyverse)
library(tidymodels)
library(tidyclust)
library(ggplot2)
```

```{r}
library(readr)

Artworks <- read_csv("Artworks - Sheet1.csv")


#demographics <- read_csv("demographics.csv")

qualtrics_data <- read_csv("clean_complete_pilot_data.csv")
```





```{r}
library(dplyr)
library(tidyr)

artworks <- Artworks
```


```{r}
qualtrics_data <- qualtrics_data %>%
  slice(-c(3:8))
```


```{r setup}
library(dplyr)


rating_columns <- names(qualtrics_data)[grepl('rating_scores', names(qualtrics_data))]


is_numeric_or_na <- function(x) {
  suppressWarnings(!is.na(as.numeric(as.character(x)))) | is.na(x)
}


filtered_qualtrics_data <- qualtrics_data %>%
  rowwise() %>%
  filter(all(sapply(c_across(all_of(rating_columns)), is_numeric_or_na))) %>%
  ungroup()

str(filtered_qualtrics_data)

filtered_qualtrics_data<- filtered_qualtrics_data %>% 
  mutate(participantID=row_number())
```


```{r}
library(dplyr)
library(tidyr)
library(stringr)


qualtrics_long <- filtered_qualtrics_data %>%
  pivot_longer(
    cols = contains('rating_scores'),
    names_to = 'Artwork_ID',
    names_pattern = '(\\d+)_rating_scores', 
    values_to = 'Rating'
  ) %>%
  mutate(Artwork_ID = as.numeric(Artwork_ID))  


```

```{r}
qualtrics_long$Rating <- as.numeric(qualtrics_long$Rating)
qualtrics_long1 <- qualtrics_long %>%
  filter(!is.na(Rating))
  
qualtrics_long1<- qualtrics_long1%>%
  group_by(participantID)%>%
  mutate(recommender_ave = mean(Rating))

```


```{r}
artworks$ID <- 1:nrow(artworks)

final_dataset <- merge(artworks, qualtrics_long, by = 'Artwork_ID')


```


Averages
```{r}
library(dplyr)
final_dataset$Rating <- as.numeric(as.character(final_dataset$Rating))

sum(is.na(final_dataset$Rating))

average_ratings_by_style <- final_dataset %>%
  filter(!is.na(Rating) & !is.na(Style)) %>%
  group_by(Style) %>%
  summarize(Average_Rating = mean(Rating, na.rm = TRUE))


print(average_ratings_by_style)

```


```{r}
library(ggplot2)
library(dplyr)

average_ratings_by_style <- final_dataset %>%
  filter(!is.na(Rating) & !is.na(Style)) %>%
  group_by(Style) %>%
  summarize(
    Average_Rating = mean(Rating, na.rm = TRUE) - 50,
    SD_Rating = sd(Rating, na.rm = TRUE),
    n = n() 
  )

average_ratings_by_style <- average_ratings_by_style %>%
  arrange(Average_Rating)

ggplot(average_ratings_by_style, aes(x = reorder(Style, Average_Rating), y = Average_Rating)) +
  geom_bar(stat = "identity", fill = "orange") +
  geom_errorbar(aes(ymin = Average_Rating - SD_Rating/sqrt(n), ymax = Average_Rating + SD_Rating/sqrt(n)), width = 0.2) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +  # Add a red dashed horizontal line at y=50
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Average Liking Ratings Across Art Styles/Movements", x = "Art Style", y = "Average Rating")+
  scale_y_continuous(breaks = seq(-50, 50, 10), limits = c(-25, 20))




```


Top 10s 
```{r}
library(dplyr)

average_ratings_by_piece <- final_dataset %>%
  group_by(Title) %>%
  summarize(Average_Rating = mean(Rating, na.rm = TRUE))

top_liked <- average_ratings_by_piece %>%
  arrange(desc(Average_Rating)) %>%
  slice_head(n = 10)


least_liked <- average_ratings_by_piece %>%
  arrange(Average_Rating) %>%
  slice_head(n = 10)


print(top_liked)
print(least_liked)

```



```{r}
df_raw <- read_csv("complete_thesis_data.csv") %>% 
  filter(rating_type != "Actual")
artworks <- read_csv("artwork-embeddings.csv")

artworks <- artworks %>% 
  pivot_longer(cols = matches("V[0-9]")) %>% 
  group_by(item,Title,Artist,Style,Genre,piclink,imglink) %>% 
  summarize(
    embedding = list(value)
  )


df_all <- df_raw %>% 
  group_by(participantID) %>% 
  filter(n() >= 40) %>%  # some have 40- and some 42 -- was this a bug in qualtrics or data processing?
  ungroup() %>% 
  rename(profile = rating_subj) %>% 
  pivot_wider(
    names_from = "rating_type",
    values_from = c("rating")
  ) %>% 
  rename(
    predicted = Target,
    recommender_rating = SelfRate,
    profile_rating = actual_rating
    ) %>% 
  select(participantID, profile, artwork, predicted, recommender_rating, profile_rating)



 df_all <- artworks %>% 
  right_join(df_all, by = c("imglink" = "artwork"))

df <- df_all %>% 
  drop_na(predicted)

df_similarities <- df_all %>% 
  filter(is.na(predicted)) %>% 
  filter(participantID != 0) %>% 
  group_by(participantID) %>% 
  mutate(
    pr_l2 = profile_rating / sqrt(sum(profile_rating^2)),
    rec_l2 = recommender_rating / sqrt(sum(recommender_rating^2))
  ) %>% 
  summarize(
    euc_dist = sqrt(sum(pr_l2 - rec_l2)^2),
    cos_sim = sum(profile_rating * recommender_rating) / (sqrt(sum(profile_rating^2)) * sqrt(sum(recommender_rating^2)))
    )

df <- left_join(df, df_similarities, by = "participantID")
df <- left_join(df, average_ratings_by_piece, by = "Title")
df <- left_join(df, qualtrics_long1 %>% select(participantID, recommender_ave), by = "participantID")

recommender_original_mean <- mean(df$recommender_rating, na.rm = TRUE)
profile_original_mean <- mean(df$profile_rating, na.rm = TRUE)

df_centered <- df %>% 
  filter(participantID > 0) %>% 
  # mutate(
  #   cos_sim = if_else(participantID==0, 0, cos_sim),
  #   euc_dist = if_else(participantID==0, 0, euc_dist),
  #   ) %>% 
  # mutate(participantID = if_else(participantID==0, -profile, participantID)) %>% 
  drop_na(cos_sim, euc_dist) %>% 
  mutate(across(c(recommender_ave), .fns = ~.x-mean(.x, na.rm=TRUE)))%>%
  group_by(participantID) %>% 
  mutate(across(c(predicted, recommender_rating, profile_rating, Average_Rating), .fns = ~.x-mean(.x, na.rm=TRUE)))
```

## quick EDA

How well do Ps do in predicting the ratings? We can quantify their mean absolute error.

```{r}
df %>% 
  filter(participantID != 0) %>%  # remove chatgpt
  group_by(participantID, profile) %>% 
  summarize(mae = mean(abs(predicted - profile_rating))) %>% 
  ggplot(aes(x=mae)) +
  geom_histogram() +
  facet_wrap(~profile) +
  xlim(0, 100)
```

And the correlation between their predicted ratings and the true ratings.

```{r}
df %>% 
  filter(participantID != 0) %>%  # remove chatgpt
  group_by(participantID, profile) %>% 
  summarize(corr = cor(predicted, profile_rating)) %>% 
  ggplot(aes(x=corr)) +
  geom_histogram() +
  facet_wrap(~profile) +
  xlim(-1, 1)
```


## How well do people predict?

```{r}
df_centered %>% 
  # filter(participantID > 0) %>% 
  # group_by(participantID) %>% 
  mutate(corr = cor(predicted, profile_rating)) %>% 
  ungroup() %>% 
  mutate(corank = dense_rank(corr)) %>% 
  ggplot(aes(x=predicted, y = profile_rating)) +
  geom_point() +
  facet_wrap(~reorder(participantID, -corank)) +
  theme(aspect.ratio = 1)
```

## Computing similarity 

**note:** profile 21 has an extra painting? or missed having Ps predict for one?

This computes the similarity between each reference painting (rated) and the target painting (to be predicted).

```{r}
df_all %>% 
  filter(participantID != 0) %>% 
  group_by(profile, participantID) %>% 
  group_by(profile) %>% 
  # summarize(max(n))
  filter(is.na(predicted)) %>% 
  distinct(profile, item, .keep_all = TRUE) %>% 
  select(profile, item, embedding) %>% 
  arrange(profile, item) %>% 
  group_by(profile) %>% 
  filter(!(profile==21 & item==190))
  # summarize(emb_list = list(embedding))

prof_ratings <- df_all %>% 
  filter(participantID != 0) %>% 
  filter(!(profile==21 & item==190)) %>% 
  group_by(profile, participantID) %>% 
  filter(n() >=23) %>% 
  filter(is.na(predicted)) %>% 
  ungroup() %>% 
  distinct(profile, item, .keep_all = TRUE) %>% 
  select(profile, item, profile_rating, embedding) %>% 
  arrange(profile, item) %>% 
  group_by(profile) %>% 
  mutate(example_num = 1:n()) %>% 
  select(-item) %>% 
  pivot_wider(
    names_from = example_num,
    values_from = c(profile_rating, embedding)
  )
  
```

```{r}
df
```


# Modeling: Ego-based

First, a model assuming Ps just predict for the target what they would rate themselves.

```{r}
IDs <- sort(unique(df_centered %>% pull(participantID)))

fit_model_ego <- function(pid){
  d <- df_centered %>% 
    filter(participantID == pid)
  return(lm(predicted ~ recommender_rating, d))
}

models_ego <- lapply(IDs, fit_model_ego)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_ego, get_R2))
  
```

Checking if cosine similarity of recommender to profile is positively associated with the derived beta weight on participant's own ratings. This would be a sign people are sensitive to how similar they themselves appear to be to the profile? Oh, looks like yes?

```{r}
df_centered %>% 
  arrange(participantID) %>% 
  ungroup() %>% 
  distinct(participantID, .keep_all = TRUE) %>% 
  mutate(mod_beta = map_dbl(models_ego, get_beta)) %>% 
  filter(participantID >= 0) %>% 
  ggplot(aes(x=cos_sim, y = mod_beta)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~profile)

df_centered %>% 
  arrange(participantID) %>% 
  ungroup() %>% 
  distinct(participantID, .keep_all = TRUE) %>% 
  mutate(mod_beta = map_dbl(models_ego, get_beta)) %>% 
  filter(participantID >= 0) %>% 
  ggplot(aes(x=euc_dist, y = mod_beta)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~profile)
```



## Allocentric models

A bunch of versions of these are possible. 

One idea could be:

$$
y_t = \alpha + \beta \frac{1}{\sum_i S(t, p_i)} \sum_i r_i \cdot S(t, p_i)
$$

Note: negative weights will predict negative values, so a high score on a dissimilar painting will lead to predicting a lower score. For this reason, I use euclidean distance.


```{r}
standardize <- function(x){
  (x - mean(x))/sd(x)
}

eucnorm <- function(x) sqrt(sum(x^2))


euc_sim_list <- function(l1, l2){
  l1 <- as.numeric(l1)
  l2 <- as.numeric(l2)
  2 - sqrt(sum((l1/eucnorm(l1) - l2/eucnorm(l2))^2))
}

cos_sim_list <- function(l1, l2){
  l1 <- as.numeric(l1)
  l2 <- as.numeric(l2)
  sum(l1 * l2) / (sqrt(sum(l1^2)) * sqrt(sum(l2^2)))
}

fit_model_allo <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6)
    ) 
  
  return(lm(predicted ~ rweighted, d))
}

models_allo <- lapply(IDs, fit_model_allo)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_allo, get_R2))
```
cos distance is significantly worse here.


### negative similarities

Can also allow negative similarities.

```{r}
# clamp <- function(x, a=0, b=Inf) {
#     pmax(a, pmin(x, b) )
# }



fit_model_allo_neg <- function(pid, simfunc = euc_sim_list){
  d <<- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    )# %>% 
    # mutate(across(contains('sim_'), clamp)) %>%
    # mutate(
    #   rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6)
  
  fit <- nlsLM(predicted ~ b + z * (profile_rating_1 * (sim_1 - a) + profile_rating_2 * (sim_2 - a) + profile_rating_3 * (sim_3 - a) + profile_rating_4 * (sim_4 - a) + profile_rating_5 * (sim_5 - a) + profile_rating_6 * (sim_6 - a) )/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6), d, start=list(a=1, b=0, z = 1), algorithm="port", 
    lower=c(0, -100, -100), upper=c(2,100, 100))
     
  return(fit)
}

models_allo_neg <- lapply(IDs, fit_model_allo_neg)

get_R2_nls <- function(mod){
  preds <- predict(mod)
  y <- preds + resid(mod)
  return(cor(preds, y)^2)
}

hist(map_dbl(models_allo_neg, get_R2_nls))
```


```{r}
get_zeropoint_par <- function(mod){
  coef(mod)[1]
}

hist(map_dbl(models_allo_neg, get_zeropoint_par))
```


Could do a "take the best" version too (this notation is wrong!)

$$
y = \alpha + \beta \big( r_i \cdot S_{max}(t, p_i)\big)
$$

```{r}

fit_model_allobest_weighted <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ weighted_closest_rating, d))
}

models_allobestweighted <- lapply(IDs, fit_model_allobest_weighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_allobestweighted, get_R2))
```
```{r with cos distance}

fit_model_cos_allobest_weighted <- function(pid, simfunc = cos_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ weighted_closest_rating, d))
}

models_cos_allobestweighted <- lapply(IDs, fit_model_cos_allobest_weighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_cos_allobestweighted, get_R2))
```

And another version where we ignore the similarity weight, just use the predicted value for most similar item.

```{r}
fit_model_allobest_unweighted <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ unweighted_closest_rating, d))
}

models_allobest_unweighted <- lapply(IDs, fit_model_allobest_unweighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

hist(map_dbl(models_allobest_unweighted, get_R2))
```

```{r}
fit_model_cos_allobest_unweighted <- function(pid, simfunc = cos_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ unweighted_closest_rating, d))
}

models_cos_allobest_unweighted <- lapply(IDs, fit_model_cos_allobest_unweighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

hist(map_dbl(models_cos_allobest_unweighted, get_R2))
```
euc and cos seem pretty similar for allobest_unweighted.


```{r}
fit_model_allo_minmax <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      min_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), min),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      ),
      unweighted_furthest_rating = case_when(
        min_sim == sim_1 ~ profile_rating_1,
        min_sim == sim_2 ~ profile_rating_2,
        min_sim == sim_3 ~ profile_rating_3,
        min_sim == sim_4 ~ profile_rating_4,
        min_sim == sim_5 ~ profile_rating_5,
        min_sim == sim_6 ~ profile_rating_6,
      ),
      rweight = unweighted_closest_rating * max_sim + (unweighted_furthest_rating * -1*min_sim)
    )
    
  
  return(lm(predicted ~ rweight, d))
}

models_allo_minmax <- lapply(IDs, fit_model_allo_minmax)

hist(map_dbl(models_allo_minmax, get_R2))
```


max_sim == sim_1 ~ sim_1*profile_rating_1,Could do a take the top-2 version, etc.

And then could allow for negative similarities with inverse ratings (i.e. if you like something X a lot, I infer you will dislike thing very different from X). -- this seems less likely to me, but it gets raised as a heuristic in some of these other prior works

## weighting in own views

```{r}
fit_model_allo_ego <- function(pid, distfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, distfunc),
      sim_2 = map2_dbl(embedding, embedding_2, distfunc),
      sim_3 = map2_dbl(embedding, embedding_3, distfunc),
      sim_4 = map2_dbl(embedding, embedding_4, distfunc),
      sim_5 = map2_dbl(embedding, embedding_5, distfunc),
      sim_6 = map2_dbl(embedding, embedding_6, distfunc)
    ) %>% 
    # mutate(across(contains("sim_"), ~1/.x)) %>% 
    mutate(
      rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6) + (recommender_rating * cos_sim)
    ) 
  
  return(lm(predicted ~ rweighted, d))
}

models_allo_ego <- lapply(IDs, fit_model_allo_ego)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_allo_ego, get_R2))
```
# popular models

```{r popular vote model}
fit_popular <- function(pid){
  d <- df_centered %>% 
    filter(participantID == pid) 
  
  return(lm(predicted ~ Average_Rating, d))
}


models_popular <- lapply(IDs, fit_popular)

hist(map_dbl(models_popular, get_R2))


map_dbl(models_popular, get_beta)
```

```{r popular ego hybrid model}
fit_popego <- function(pid){
  d <- df_centered %>% 
    filter(participantID == pid) 
  
  return(lm(predicted ~ Average_Rating + recommender_rating, d))
}


models_popego <- lapply(IDs, fit_popego)

hist(map_dbl(models_popego, get_R2))


map_dbl(models_popego, get_beta)
```

```{r popular ego allo model}
standardize <- function(x){
  (x - mean(x))/sd(x)
}

eucnorm <- function(x) sqrt(sum(x^2))


euc_sim_list <- function(l1, l2){
  l1 <- as.numeric(l1)
  l2 <- as.numeric(l2)
  2 - sqrt(sum((l1/eucnorm(l1) - l2/eucnorm(l2))^2))
}

cos_sim_list <- function(l1, l2){
  l1 <- as.numeric(l1)
  l2 <- as.numeric(l2)
  sum(l1 * l2) / (sqrt(sum(l1^2)) * sqrt(sum(l2^2)))
}

fit_popego_allo <- function(pid, simfunc = euc_sim_list){
   d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      rweighted =  Average_Rating + recommender_rating + (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6) 
    ) 
  
  return(lm(predicted ~ rweighted, d))
}

models_popego_allo <- lapply(IDs, fit_popego_allo)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_popego_allo, get_R2))
```

```{r popular allo model}
fit_pop_allo <- function(pid, simfunc = euc_sim_list){
   d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6) + Average_Rating 
    ) 
  
  return(lm(predicted ~ rweighted, d))
}

models_pop_allo <- lapply(IDs, fit_pop_allo)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_pop_allo, get_R2))
```

```{r popular allo neg model}
fit_pop_allo_neg <- function(pid, simfunc = euc_sim_list){
  d <<- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    )# %>% 
    # mutate(across(contains('sim_'), clamp)) %>%
    # mutate(
    #   rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6)
  
  fit <- nlsLM(predicted ~ Average_Rating + b + z * (profile_rating_1 * (sim_1 - a) + profile_rating_2 * (sim_2 - a) + profile_rating_3 * (sim_3 - a) + profile_rating_4 * (sim_4 - a) + profile_rating_5 * (sim_5 - a) + profile_rating_6 * (sim_6 - a) )/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6), d, start=list(a=1, b=0, z = 1), algorithm="port", 
    lower=c(0, -100, -100), upper=c(2,100, 100) )
     
  return(fit)
}

models_pop_allo_neg <- lapply(IDs, fit_pop_allo_neg)

get_R2_nls <- function(mod){
  preds <- predict(mod)
  y <- preds + resid(mod)
  return(cor(preds, y)^2)
}

hist(map_dbl(models_pop_allo_neg, get_R2_nls))
```
```{r popular ego allo neg model}
fit_popego_allo_neg <- function(pid, simfunc = euc_sim_list){
  d <<- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    )# %>% 
    # mutate(across(contains('sim_'), clamp)) %>%
    # mutate(
    #   rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6)
  
  fit <- nlsLM(predicted ~ recommender_rating + Average_Rating + b + z * (profile_rating_1 * (sim_1 - a) + profile_rating_2 * (sim_2 - a) + profile_rating_3 * (sim_3 - a) + profile_rating_4 * (sim_4 - a) + profile_rating_5 * (sim_5 - a) + profile_rating_6 * (sim_6 - a) )/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6), d, start=list(a=1, b=0, z = 1), algorithm="port", 
    lower=c(0, -100, -100), upper=c(2,100, 100) )
     
  return(fit)
}

models_popego_allo_neg <- lapply(IDs, fit_popego_allo_neg)

get_R2_nls <- function(mod){
  preds <- predict(mod)
  y <- preds + resid(mod)
  return(cor(preds, y)^2)
}

hist(map_dbl(models_popego_allo_neg, get_R2_nls))
```

```{r popular ego allo neg model}
fit_cos_popego_allo_neg <- function(pid, simfunc = cos_sim_list){
  d <<- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    )# %>% 
    # mutate(across(contains('sim_'), clamp)) %>%
    # mutate(
    #   rweighted = (profile_rating_1 * sim_1 + profile_rating_2 * sim_2 + profile_rating_3 * sim_3 + profile_rating_4 * sim_4 + profile_rating_5 * sim_5 + profile_rating_6 * sim_6)/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6)
  
  fit <- nlsLM(predicted ~ recommender_rating + Average_Rating + b + z * (profile_rating_1 * (sim_1 - a) + profile_rating_2 * (sim_2 - a) + profile_rating_3 * (sim_3 - a) + profile_rating_4 * (sim_4 - a) + profile_rating_5 * (sim_5 - a) + profile_rating_6 * (sim_6 - a) )/(sim_1 + sim_2 + sim_3 + sim_4 + sim_5 + sim_6), d, start=list(a=1, b=0, z = 1), algorithm="port", 
    lower=c(0, -100, -100), upper=c(2,100, 100) )
     
  return(fit)
}

models_cos_popego_allo_neg <- lapply(IDs, fit_cos_popego_allo_neg)

get_R2_nls <- function(mod){
  preds <- predict(mod)
  y <- preds + resid(mod)
  return(cor(preds, y)^2)
}

hist(map_dbl(models_cos_popego_allo_neg, get_R2_nls))
```



```{r}
fit_pop_allobest_weighted <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ weighted_closest_rating + Average_Rating, d))
}

models_pop_allobestweighted <- lapply(IDs, fit_pop_allobest_weighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_pop_allobestweighted, get_R2))
```

```{r}
fit_cos_pop_allobest_weighted <- function(pid, simfunc = cos_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ weighted_closest_rating + Average_Rating, d))
}

models_cos_pop_allobestweighted <- lapply(IDs, fit_cos_pop_allobest_weighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_cos_pop_allobestweighted, get_R2))
```



```{r}
fit_pop_allobest_unweighted <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ unweighted_closest_rating + Average_Rating, d))
}

models_pop_allobest_unweighted <- lapply(IDs, fit_pop_allobest_unweighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

hist(map_dbl(models_pop_allobest_unweighted, get_R2))
```


```{r}
fit_cos_pop_allobest_unweighted <- function(pid, simfunc = cos_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ unweighted_closest_rating + Average_Rating, d))
}

models_cos_pop_allobest_unweighted <- lapply(IDs, fit_cos_pop_allobest_unweighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

hist(map_dbl(models_cos_pop_allobest_unweighted, get_R2))
```


```{r}
fit_popego_allobest_weighted <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ recommender_rating + weighted_closest_rating + Average_Rating, d))
}

models_popego_allobestweighted <- lapply(IDs, fit_popego_allobest_weighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_popego_allobestweighted, get_R2))
```



```{r}
fit_cos_popego_allobest_weighted <- function(pid, simfunc = cos_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ recommender_rating + weighted_closest_rating + Average_Rating, d))
}

models_cos_popego_allobestweighted <- lapply(IDs, fit_cos_popego_allobest_weighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

get_beta <- function(mod){
  x <- mod$coefficients[2]
  return(x)
}

hist(map_dbl(models_cos_popego_allobestweighted, get_R2))
```



```{r}
fit_popego_allobest_unweighted <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ recommender_rating + unweighted_closest_rating + Average_Rating, d))
}

models_popego_allobest_unweighted <- lapply(IDs, fit_popego_allobest_unweighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

hist(map_dbl(models_popego_allobest_unweighted, get_R2))
```


```{r}
fit_cos_popego_allobest_unweighted <- function(pid, simfunc = cos_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      weighted_closest_rating = case_when(
        max_sim == sim_1 ~ max_sim*profile_rating_1,
        max_sim == sim_2 ~ max_sim*profile_rating_2,
        max_sim == sim_3 ~ max_sim*profile_rating_3,
        max_sim == sim_4 ~ max_sim*profile_rating_4,
        max_sim == sim_5 ~ max_sim*profile_rating_5,
        max_sim == sim_6 ~ max_sim*profile_rating_6,
      ),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      )
    )
  
  return(lm(predicted ~ recommender_rating + unweighted_closest_rating + Average_Rating, d))
}

models_cos_popego_allobest_unweighted <- lapply(IDs, fit_cos_popego_allobest_unweighted)

get_R2 <- function(mod){
  x <- summary(mod)$r.squared
  return(x)
}

hist(map_dbl(models_popego_allobest_unweighted, get_R2))
```




```{r}
fit_pop_allo_minmax <- function(pid, simfunc = euc_sim_list){
  d <- df_centered %>% 
    filter(participantID == pid) %>% 
    left_join(prof_ratings, by = "profile") %>% 
    mutate(
      sim_1 = map2_dbl(embedding, embedding_1, simfunc),
      sim_2 = map2_dbl(embedding, embedding_2, simfunc),
      sim_3 = map2_dbl(embedding, embedding_3, simfunc),
      sim_4 = map2_dbl(embedding, embedding_4, simfunc),
      sim_5 = map2_dbl(embedding, embedding_5, simfunc),
      sim_6 = map2_dbl(embedding, embedding_6, simfunc)
    ) %>% 
    mutate(
      max_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), max),
      min_sim = pmap_dbl(list(sim_1, sim_2, sim_3, sim_4, sim_5, sim_6), min),
      unweighted_closest_rating = case_when(
        max_sim == sim_1 ~ profile_rating_1,
        max_sim == sim_2 ~ profile_rating_2,
        max_sim == sim_3 ~ profile_rating_3,
        max_sim == sim_4 ~ profile_rating_4,
        max_sim == sim_5 ~ profile_rating_5,
        max_sim == sim_6 ~ profile_rating_6,
      ),
      unweighted_furthest_rating = case_when(
        min_sim == sim_1 ~ profile_rating_1,
        min_sim == sim_2 ~ profile_rating_2,
        min_sim == sim_3 ~ profile_rating_3,
        min_sim == sim_4 ~ profile_rating_4,
        min_sim == sim_5 ~ profile_rating_5,
        min_sim == sim_6 ~ profile_rating_6,
      ),
      rweight = unweighted_closest_rating * max_sim + (unweighted_furthest_rating * -1*min_sim) + Average_Rating
    )
    
  
  return(lm(predicted ~ rweight, d))
}

models_popallo_minmax <- lapply(IDs, fit_pop_allo_minmax)

hist(map_dbl(models_popallo_minmax, get_R2))
```



# Broken models
```{r profile ave model}
fit_profile_ave <- function(pid){
  d <- df_centered %>%
    filter(participantID == pid) %>%
    mutate(
      profile_rating_uncentered = profile_rating + profile_original_mean  
    ) %>%
    group_by(profile) %>%
    mutate(
      profile_ave = mean(profile_rating_uncentered, na.rm = TRUE)  
    ) %>%
    ungroup()
  
  return(lm(predicted ~ profile_ave, d))  
}


models_prof_ave <- lapply(IDs, fit_profile_ave)


hist(map_dbl(models_prof_ave, get_R2))


map_dbl(models_prof_ave, get_beta)

```

```{r recommender ave}
fit_recomm_ave <- function(pid){
  d <- df_centered %>% 
    filter(participantID == pid)
  
  return(lm(predicted ~ recommender_ave, d))  
}


models_rec_ave <- lapply(IDs, fit_recomm_ave)


hist(map_dbl(models_rec_ave, get_R2))


map_dbl(models_rec_ave, get_beta)

```
Getting NAs 


# Pure chance

```{r Monte Carlo simulation}
set.seed(123) 


n_simulations <- 100000
n_points <- 18


correlations <- numeric(n_simulations)

for (i in 1:n_simulations) {
  true_ratings <- runif(n_points, min = 0, max = 100)
  guessed_ratings <- runif(n_points, min = 0, max = 100)
  correlations[i] <- cor(true_ratings, guessed_ratings)
}


probability <- mean(correlations > 0.5)
print(paste("Probability of correlation > 0.5: ", probability))


hist(correlations, breaks = 50, main = "Simulated Distribution of Correlations Under Random Guessing",
     xlab = "Correlation", col = "lightblue", border = "black")
abline(v = 0.5, col = "red", lwd = 2, lty = 2)

```


# Comparing models

```{r}

df_with_fits <- df_centered %>% 
  group_by(participantID, profile, cos_sim, euc_dist) %>% 
  summarize(
    mae = mean(abs(predicted - profile_rating)),
    corr =cor(predicted, profile_rating),
     TSS = var(predicted)*n(),
    N = n()
    ) %>% 
  ungroup() %>% 
  arrange(participantID) %>% 
  mutate(
    ego_r2 = map_dbl(models_ego, get_R2),
    allo_r2 = map_dbl(models_allo, get_R2),
    allo_neg_r2 = map_dbl(models_allo_neg, get_R2_nls),
    allobest_r2 = map_dbl(models_allobest_unweighted, get_R2),
    allo_minmax_r2 = map_dbl(models_allo_minmax, get_R2),
    hybrid_r2 = map_dbl(models_allo_ego, get_R2),
    popular_r2 = map_dbl(models_popular, get_R2),
    popego_r2 = map_dbl(models_popego, get_R2),
    popego_allo_r2 = map_dbl(models_popego_allo, get_R2),
    pop_allo_r2 = map_dbl(models_pop_allo, get_R2), 
    pop_allo_neg_r2 = map_dbl(models_pop_allo_neg,get_R2_nls),
    pop_allo_best_r2 = map_dbl(models_pop_allobestweighted, get_R2),
    pop_allo_bestunw_r2 = map_dbl(models_pop_allobest_unweighted, get_R2),
    pop_allo_minmax_r2= map_dbl(models_popallo_minmax, get_R2),
    popego_allo_neg_r2 = map_dbl(models_popego_allo_neg, get_R2_nls),
    popego_allo_best_r2 = map_dbl(models_popego_allobestweighted, get_R2),
    popego_allo_bestunw_r2 = map_dbl(models_popego_allobest_unweighted, get_R2)
  ) %>% 
  mutate(
    max_r2 = pmap_dbl(list(ego_r2,allo_r2, allobest_r2, allo_neg_r2, hybrid_r2, allo_minmax_r2,popular_r2, popego_r2, popego_allo_r2, pop_allo_r2, pop_allo_neg_r2, pop_allo_best_r2, pop_allo_minmax_r2, popego_allo_neg_r2, popego_allo_best_r2, popego_allo_bestunw_r2), max),
    best_model = case_when(
      max_r2 == ego_r2 ~ "ego",
      max_r2 == allo_r2 ~ "allo",
      max_r2 == allo_neg_r2 ~ "allo_neg",
      max_r2 == allobest_r2 ~ "allobest",
      max_r2 == allo_minmax_r2 ~ "allominmax",
      max_r2 == hybrid_r2 ~ "hybrid",
      max_r2 == popular_r2 ~ "popular",
      max_r2 == popego_r2 ~ "popego",
      max_r2 == popego_allo_r2 ~"popego_allo",
      max_r2 == pop_allo_r2 ~"pop_allo", 
      max_r2 == pop_allo_neg_r2 ~ "pop_allo_neg",
      max_r2 == pop_allo_best_r2 ~ "pop_allo_best",
      max_r2 == pop_allo_bestunw_r2 ~ "pop_allo_bestunw",
      max_r2 == pop_allo_minmax_r2 ~ "pop_allo_minmax",
      max_r2 == popego_allo_neg_r2 ~"popego_allo_neg",
      max_r2 == popego_allo_best_r2 ~ "popego_allo_best",
      max_r2 == popego_allo_bestunw_r2 ~ "popego_allo_bestunw"
      
    )
  )

df_with_fits %>% 
  count(best_model)
```
popego_allo_best seems to have by far absorbed lots of the cases when added. Without it its a lot more disparate. 
# Top three models per participant
```{r}

df_with_fits1 <- df_centered %>% 
  group_by(participantID, profile, cos_sim, euc_dist) %>% 
  summarize(
    mae = mean(abs(predicted - profile_rating)),
    corr = cor(predicted, profile_rating)
  ) %>% 
  ungroup() %>% 
  arrange(participantID) %>% 
  mutate(
    ego_r2 = map_dbl(models_ego, get_R2),
    allo_r2 = map_dbl(models_allo, get_R2),
    allo_neg_r2 = map_dbl(models_allo_neg, get_R2_nls),
    allobest_r2 = map_dbl(models_allobest_unweighted, get_R2),
    allo_minmax_r2 = map_dbl(models_allo_minmax, get_R2),
    hybrid_r2 = map_dbl(models_allo_ego, get_R2),
    popular_r2 = map_dbl(models_popular, get_R2),
    popego_r2 = map_dbl(models_popego, get_R2),
    popego_allo_r2 = map_dbl(models_popego_allo, get_R2),
    pop_allo_r2 = map_dbl(models_pop_allo, get_R2), 
    pop_allo_neg_r2 = map_dbl(models_pop_allo_neg, get_R2_nls),
    pop_allo_best_r2 = map_dbl(models_pop_allobestweighted, get_R2),
    pop_allo_bestunw_r2 = map_dbl(models_pop_allobest_unweighted, get_R2),
    pop_allo_minmax_r2 = map_dbl(models_popallo_minmax, get_R2),
    popego_allo_neg_r2 = map_dbl(models_popego_allo_neg, get_R2_nls),
    popego_allo_best_r2 = map_dbl(models_popego_allobestweighted, get_R2),
    popego_allo_bestunw_r2 = map_dbl(models_popego_allobest_unweighted, get_R2)
  ) 

df_long1 <- df_with_fits1 %>%
  pivot_longer(
    cols = starts_with("ego_r2"):starts_with("popego_allo_bestunw_r2"),
    names_to = "model",
    values_to = "r2_value"
  )


 df_long1 %>%
  group_by(participantID) %>%
  select(participantID, profile, model, r2_value, corr)%>%
  arrange(desc(r2_value)) %>%
  slice_head(n = 3) %>%
  ungroup()



```


```{r}
df_with_fits %>% 
  ggplot(aes(x=max_r2)) +
  geom_histogram()
```

```{r}

df_with_fits %>% 
  ungroup() %>% 
  mutate(mod_beta = map_dbl(models_ego, get_beta)) %>% 
  filter(best_model == "ego") %>%
  ggplot(aes(x=cos_sim, y = mod_beta)) +
  geom_point() +
  geom_smooth(method = "lm")


df_with_fits %>% 
  ungroup() %>% 
  mutate(mod_beta = map_dbl(models_ego, get_beta)) %>% 
  filter(best_model == "ego") %>%
  ggplot(aes(x=euc_dist, y = mod_beta)) +
  geom_point() +
  geom_smooth(method = "lm")
```

That is significant positive relationship with cosine similarity. (funny, looked like it wouldn't be in the plot). So there's some evidence the egocentric folks do take their own similarity to the target into account in their estimates. 

```{r}
df_with_fits %>% 
  ungroup() %>% 
  mutate(mod_beta = map_dbl(models_ego, get_beta)) %>% 
  filter(best_model == "ego") -> x

summary(lm(mod_beta ~ cos_sim, x))
summary(lm(mod_beta ~ euc_dist, x))
```



## Comparing predictions

No strategy is a clear winner.

```{r}
df_with_fits %>% 
  ggplot(aes(x=best_model, y = mae)) +
  geom_boxplot(alpha = .25) +
  geom_jitter(width = .1) 
```


```{r}
df_with_fits %>% 
  # filter(cos_sim > .50) %>% 
  # mutate(allo_or_ego = if_else(best_model == 'ego', "ego", "allo")) %>%
  ggplot(aes(x=cos_sim, y = mae)) +
  geom_point()+
  # facet_wrap(~allo_or_ego) +
  geom_smooth(method='lm')
```

being simlar to the target seems to worsen predictions, if anything. Though the relationship is weak. 

## How well do participants and our best-fitting models predict? Should we look for other models?

Looking through some examples manually, for the most accurate predictors, predictions are well-explained by ego-based models where those are the best-fitting models. But they are fairly poorly explained by allocentrtic models where those are the best-fitting. So a task could be to figure out what those people are doing -- possibly soome weighted combination of ego-centric and allocentric? Maybe something else?


```{r}
df_with_fits %>% 
  # filter(participantID > 0) %>% 
  # group_by(participantID) %>% 
  # mutate(corr = cor(predicted, profile_rating)) %>% 
  ungroup() %>% 
  distinct(participantID, best_model, corr, max_r2) %>% 
  mutate(prank = percent_rank(corr)) %>% 
  # filter(prank > .90) %>% 
  arrange(-max_r2)
```

Some more work to do here. If a person is predicting poorly and all our models predict their behavior poorly, well then maybe they are just noisy/sloppy. But if they are doing a good job, then we want a model that does a good job describing their behavior. 

Additional notes: 
Popular better predicts the worse the rater did if it was the best performing model.

Judging from the random guess distribution, anything above ~.4 or ~.5 corr is pretty impressive. 
What's an r2 value where we can say that a person is likely using this model or something similar? r2>=.5? r would be ~.7, decently strong correlation. If so then we can say we can model for ~50% of participants, keep finding models to meet that criteria? 

Popular ego hybrid model: Seems very successful, but there are still high correlation low R2 cases unaccounted for, also it has really high R2 for cases with both poor and good correlations, break apart by profile to see if this strategy is only successful with the more mainstream profiles and sucks at more eccentric profiles. 

Models with more predictors do better but not by a lot in each case. For minor improvements, do we go with the simpler model?




```{r}
df_with_fits %>% 
  filter(max_r2 < .3) %>%
  ggplot(aes(x=corr)) +
  geom_histogram() 
```



----

next steps:
- be more systematic: euclidean and cosine versions of each model [Matt]
- baseline models: [matt]
  - popularity: guessing average rating from S1
  - target average: guessing target's average rating for all
  - respondent average: guess your own average each time
- Random chance: [matt]
  - What is prob of correlation > .75 if just randomly guessing at 18 points? compare distributions of our poorly-fit participants with this random chance distribution
- Negative similarity: fitting a parameter to determine midpoint (zeropoint) [Derek] [done]
- move to AIC (Akaike) weights rather than R2 selection + create visualization [Derek]

----

# chatgpt stuff

I broke this with some recent code changes above. This wasn't looking particularly promising wrt identifying different strategies IMO.

```{r}
df_with_fits %>% 
  filter(participantID < 0)
```

```{r}
df %>% 
  filter(participantID == 0) %>% 
  ggplot(aes(x=predicted, y = profile_rating)) +
  geom_point() +
  facet_wrap(~profile) +
  theme(aspect.ratio = 1)
```

Generally, I guess it does OK

# Results


## histogram of correlations


```{r}
ggplot(df_with_fits, aes(x = as.factor(participantID), y = corr)) +
  geom_histogram(stat = "identity", binwidth = 0.1) +  # Adjust binwidth as needed
  facet_wrap(~ profile, scales = "free_x") +  # Facet by profile, adjust x scales independently
  labs(x = "Participant ID", y = "Correlation (Corr)") +
  theme(axis.text.x = element_blank(),  # Hide x-axis labels to reduce clutter
        axis.ticks.x = element_blank()) +
  ggtitle("Histogram of Correlations Faceted by Profile")
```

```{r}
ggplot(df_with_fits, aes(x = corr)) +
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black") +  
  labs(x = "Correlation (Corr)", y = "Count") +
  ggtitle("Distribution of Participant's Correlations")+
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()   
  )+
  geom_vline(xintercept = 0.5, color = "red", linetype = "dashed", size = 1.5)


probability1 <- mean(df_with_fits$corr > 0.5)
print(paste("Probability of correlation > 0.5: ", probability))
```
Easier story to tell but may have too wide of binwidth

```{r}
df_scatter <- df_with_fits %>%
  arrange(corr) %>%  
  mutate(rank = percent_rank(corr),  
         group = case_when(
           rank >= 0.9 ~ "Best 10% of Participants",  
           rank >= 0.45 & rank <= 0.55 ~ "Near Average Participants", 
           rank <= 0.1 ~ "Worst 10% of Participants", 
           TRUE ~ NA_character_ 
         )) %>%
  filter(!is.na(group))
```


```{r}
ggplot(df_scatter, aes(x = participantID, y = corr)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "maroon") +
  labs(x = "Participant ID", y = "Correlation (Corr)", title = "Accuracies for the Best, Average, and Worst Participants") +
  facet_wrap(~ group) +  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
   # panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()   
  )+
  theme(
    strip.text = element_text(size = 10),  
    axis.text.x = element_text(angle = 45, hjust = 1)  
  )
```

## MAE of RS vs people

```{r}
# recomm_data<- filtered_qualtrics_data %>%
#   select(-StartDate, -EndDate, -Progress, -`Duration (in seconds)`, -Finished, -RecordedDate, -DistributionChannel, -UserLanguage, -consent, -visits, -art_knowledge, -opens_1, -opens_2, -opens_3, -edu, -age, -gender, -`gender _4_TEXT`, -participantID)

# This should get you started -- DP 2024-04-30
recomm_data <- final_dataset %>% 
  select(participantID, ID, Rating)

recomm_data_wide <- recomm_data %>% 
  spread(ID, Rating) 
```


```{r}

recomm_data_wide_filtered <- recomm_data_wide %>% 
  pivot_longer(-participantID) %>% 
  group_by(participantID) %>% 
  filter(sum(!is.na(value)) == 60) %>% 
  spread(name, value)
recomm_data_wide_filtered
```


```{r}

library(recommenderlab)

zscore <- function(x){
  (x - mean(x, na.rm=TRUE))/sd(x, na.rm=TRUE)
}

x <- recomm_data_wide_filtered %>% 
  ungroup() #%>% 
  # mutate(across(-"participantID", zscore))


ratings_data <- as(as.matrix(x %>% select(-participantID)), "realRatingMatrix")

train <- ratings_data[1:250,]
```



```{r}
scheme <- evaluationScheme(train, method = "cross-validation", k = 10, given = -5, goodRating = 50)

algorithms <- list(
  `random items` = list(name = "RANDOM", param = NULL), 
  `popular items` = list(name = "POPULAR", param = NULL),
  `user-based CF` = list(name = "UBCF", param = list(nn = 3)),
  `item-based CF` = list(name = "IBCF", param = list(k = 10)),
  `funk-svd-hd` = list(name ="SVDF", param = list(k = 10)),
  `funk-svd-ld` = list(name ="SVDF", param = list(k = 3))
  )

results <- evaluate(scheme, algorithms, type = "ratings", progress = FALSE)


```

All recommender approaches do better than random, so at least there's that. Funk-svd seems to do somewhat better than "popular"-based recommender systems. So there is some hint of personalizability here. 


```{r}

library(stringr)


get_MAE <- function(res){
  map(res, ~.x[3])
}

res_getter <- function(results){
  n <- names(results)
  reslist <- lapply(results, getResults)
  v <- map(reslist, get_MAE) %>% unlist()
  
  tibble(
    alg = names(v),
    val = v
  ) %>% 
    mutate(
      fold = str_extract(alg, "\\d{1,2}(?!.*\\d{1,2})"),
      alg = str_remove(alg, fold)
      )
    
  # lapply(reslist, ~tibble(.x[1,]))
}           

chunk1_data <- res_getter(results)


chunk2_data <- df_centered %>%
  filter(participantID != 0) %>%
  group_by(participantID) %>%
  summarize(val = mean(abs(predicted - profile_rating))) %>%
  mutate(alg = "All Participants")


chunk3_data <- df_centered %>%
  filter(participantID != 0) %>%
  group_by(participantID) %>%
  summarize(val = mean(abs(predicted - profile_rating))) %>%
  filter(val <= quantile(val, 0.20)) %>%
  mutate(alg = "Best 20% of Participants")


combined_data <- bind_rows(chunk1_data, chunk2_data, chunk3_data)


ggplot(combined_data, aes(x = alg, y = val)) +
  geom_boxplot() +
  coord_flip() +
  labs(y = "MAE", x = "Recommender", title = "Recommender Systems Versus Human Participants")+
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
   # panel.grid.major = element_blank(), 
    #panel.grid.minor = element_blank()   
  )

# x <- lapply(results, getResults)
# map2(names(results), results, ~as_tibble(getResults(.y)) %>% mutate(namez = .x))
```
```{r}
df_centered %>% 
  filter(participantID != 0) %>%  
  group_by(participantID) %>% 
  summarize(mae = mean(abs(predicted - profile_rating))) %>% 
  ggplot(aes(x=mae)) +
  geom_boxplot() 
```
```{r}
df_centered %>% 
  filter(participantID != 0) %>%  
  group_by(participantID) %>% 
  summarize(mae = mean(abs(predicted - profile_rating))) %>% 
 filter(mae <= quantile(mae, 0.2))%>%
  ggplot(aes(x=mae)) +
  geom_boxplot() 
```
```{r}
library(tidyverse)
library(stringr)

chunk1_data <- res_getter(results) %>%
  mutate(source = "Chunk 1")

chunk2_data <- df_centered %>%
  filter(participantID != 0) %>%
  group_by(participantID) %>%
  summarize(val = mean(abs(predicted - profile_rating))) %>%
  mutate(alg = "Chunk 2", source = "Chunk 2")

chunk3_data <- df_centered %>%
  filter(participantID != 0) %>%
  group_by(participantID) %>%
  summarize(val = mean(abs(predicted - profile_rating))) %>%
  filter(val <= quantile(val, 0.2)) %>%
  mutate(alg = "Chunk 3", source = "Chunk 3")


combined_data <- bind_rows(chunk1_data, chunk2_data, chunk3_data)

ggplot(combined_data, aes(x = source, y = val)) +
  geom_boxplot() +
  coord_flip() +
  labs(x = "Source", y = "MAE", title = "Combined Box Plot of MAE from Three Chunks")

```
### AIC 


```{r}

r2aic <- function(R2, TSS, n, k){
  RSS <- (1-R2)*TSS
  aic <- n * log(RSS/n) + 2 * k
  return(aic)
}



r2aic_c <- function(R2, TSS, n, k){
  RSS <- (1-R2) * TSS
  aic <- n * log(RSS/n) + 2 * k
  return(aic + (2 * k^2 + 2 * k) / (n - k - 1))
}


df_aic_fit <- df_centered %>% 
  group_by(participantID, profile, cos_sim, euc_dist) %>% 
  summarize(
    mae = mean(abs(predicted - profile_rating)),
    corr = cor(predicted, profile_rating),
    TSS = var(predicted) * n()  
  ) %>% 
  ungroup() %>% 
  arrange(participantID) %>% 
  mutate(
    ego_r2 = map_dbl(models_ego, get_R2),
    allo_r2 = map_dbl(models_allo, get_R2),
    allo_neg_r2 = map_dbl(models_allo_neg, get_R2_nls),
    allobest_r2 = map_dbl(models_allobest_unweighted, get_R2),
    allo_minmax_r2 = map_dbl(models_allo_minmax, get_R2),
    hybrid_r2 = map_dbl(models_allo_ego, get_R2),
    popular_r2 = map_dbl(models_popular, get_R2),
    popego_r2 = map_dbl(models_popego, get_R2),
    popego_allo_r2 = map_dbl(models_popego_allo, get_R2),
    pop_allo_r2 = map_dbl(models_pop_allo, get_R2), 
    pop_allo_neg_r2 = map_dbl(models_pop_allo_neg, get_R2_nls),
    pop_allo_best_r2 = map_dbl(models_pop_allobestweighted, get_R2),
    pop_allo_bestunw_r2 = map_dbl(models_pop_allobest_unweighted, get_R2),
    pop_allo_minmax_r2 = map_dbl(models_popallo_minmax, get_R2),
    popego_allo_neg_r2 = map_dbl(models_popego_allo_neg, get_R2_nls),
    popego_allo_best_r2 = map_dbl(models_popego_allobestweighted, get_R2),
    popego_allo_bestunw_r2 = map_dbl(models_popego_allobest_unweighted, get_R2),
    
   
    n = n(),

    
    ego_aic = pmap_dbl(list(ego_r2, TSS, n, 2), r2aic_c),  
    allo_aic = pmap_dbl(list(allo_r2, TSS, n, 2), r2aic_c),  
    allo_neg_aic = pmap_dbl(list(allo_neg_r2, TSS, n, 2), r2aic_c),  
    allobest_aic = pmap_dbl(list(allobest_r2, TSS, n, 2), r2aic_c),  
    allo_minmax_aic = pmap_dbl(list(allo_minmax_r2, TSS, n, 2), r2aic_c), 
    hybrid_aic = pmap_dbl(list(hybrid_r2, TSS, n, 3), r2aic_c),  
    popular_aic = pmap_dbl(list(popular_r2, TSS, n, 2), r2aic_c),  
    popego_aic = pmap_dbl(list(popego_r2, TSS, n, 3), r2aic_c),  
    popego_allo_aic = pmap_dbl(list(popego_allo_r2, TSS, n, 4), r2aic_c),  
    pop_allo_aic = pmap_dbl(list(pop_allo_r2, TSS, n, 3), r2aic_c),  
    pop_allo_neg_aic = pmap_dbl(list(pop_allo_neg_r2, TSS, n, 3), r2aic_c),  
    pop_allo_best_aic = pmap_dbl(list(pop_allo_best_r2, TSS, n, 3), r2aic_c),  
    pop_allo_bestunw_aic = pmap_dbl(list(pop_allo_bestunw_r2, TSS, n, 3), r2aic_c),  
    pop_allo_minmax_aic = pmap_dbl(list(pop_allo_minmax_r2, TSS, n, 3), r2aic_c),  
    popego_allo_neg_aic = pmap_dbl(list(popego_allo_neg_r2, TSS, n, 4), r2aic_c),  
    popego_allo_best_aic = pmap_dbl(list(popego_allo_best_r2, TSS, n, 4), r2aic_c),  
    popego_allo_bestunw_aic = pmap_dbl(list(popego_allo_bestunw_r2, TSS, n, 4), r2aic_c)  
  ) %>% 
  
  mutate(
    min_aic = pmap_dbl(list(ego_aic, allo_aic, allobest_aic, allo_neg_aic, hybrid_aic, allo_minmax_aic, popular_aic, popego_aic, popego_allo_aic, pop_allo_aic, pop_allo_neg_aic, pop_allo_best_aic, pop_allo_minmax_aic, popego_allo_neg_aic, popego_allo_best_aic, popego_allo_bestunw_aic), min),
    best_model = case_when(
      min_aic == ego_aic ~ "ego",
      min_aic == allo_aic ~ "allo",
      min_aic == allo_neg_aic ~ "allo_neg",
      min_aic == allobest_aic ~ "allobest",
      min_aic == allo_minmax_aic ~ "allominmax",
      min_aic == hybrid_aic ~ "hybrid",
      min_aic == popular_aic ~ "popular",
      min_aic == popego_aic ~ "popego",
      min_aic == popego_allo_aic ~ "popego_allo",
      min_aic == pop_allo_aic ~ "pop_allo",
      min_aic == pop_allo_neg_aic ~ "pop_allo_neg",
      min_aic == pop_allo_best_aic ~ "pop_allo_best",
      min_aic == pop_allo_bestunw_aic ~ "pop_allo_bestunw",
      min_aic == pop_allo_minmax_aic ~ "pop_allo_minmax",
      min_aic == popego_allo_neg_aic ~ "popego_allo_neg",
      min_aic == popego_allo_best_aic ~ "popego_allo_best",
      min_aic == popego_allo_bestunw_aic ~ "popego_allo_bestunw"
    )
  )

df_aic_fit %>% 
  count(best_model)

```
```{r}
df_aic_fit %>% 
  # filter(participantID > 0) %>% 
  # group_by(participantID) %>% 
  # mutate(corr = cor(predicted, profile_rating)) %>% 
  ungroup() %>% 
  distinct(participantID, best_model, corr, min_aic) %>% 
  mutate(prank = percent_rank(corr)) %>% 
  # filter(prank > .90) %>% 
  arrange(-corr)
 # arrange(-desc(min_aic))
```

```{r}
df_aic_graph <- df_aic_fit %>% 
  # filter(participantID > 0) %>% 
  # group_by(participantID) %>% 
  # mutate(corr = cor(predicted, profile_rating)) %>% 
  ungroup() %>% 
  distinct(participantID, best_model, corr, min_aic, R2) %>% 
  mutate(prank = percent_rank(corr))


df_aic_graph <- df_aic_graph %>%
  mutate(
    best_model_grouped = case_when(
      best_model %in% c("allo", "allo_neg", "allominmax") ~ "Allocentric",
      best_model %in% c("pop_allo", "pop_allo_best", "pop_allo_neg") ~ "Popular + Allocentric",
      best_model %in% c("popego_allo_best", "popego_allo_bestunw", "popego_allo_neg") ~ "Popular + Egocentric + Allocentric",
      best_model %in% c("popego") ~ "Popular + Egocentric", 
      best_model %in% c("ego") ~ "Egocentric", 
      best_model %in% c("hybrid") ~ "Allocentric + Egocentric",
      TRUE ~ best_model  
    )
  )


  ggplot(df_aic_graph, aes(x = corr))+
geom_histogram(binwidth = 0.05, fill = "steelblue", color = "black") +
  labs(x = "Correlation (Corr)", y = "Count", title = "Histogram of Correlation Faceted by Best Model") +
  facet_wrap(~ best_model_grouped) +  
  theme_minimal() +
  theme(
    strip.text = element_text(size = 10),  
    axis.text.x = element_text(angle = 45, hjust = 1) 
  )
```
```{r}
# aic

r2aic <- function(R2, TSS, n, k){
  RSS <- (1-R2)*TSS
  aic <- n * log(RSS/n) + 2 * k
  return(aic)
}


r2aic_c <- function(R2, TSS, n, k){
  RSS <- (1-R2)*TSS
  aic <- n * log(RSS/n) + 2 * k
  return(aic + (2*k^2 + 2*k)/(n-k-1) )
}




get_num_params <- function(model_name) {
  model_params <- list(
    "ego_r2" = 2,               
    "allo_r2" = 2,              
    "allo_neg_r2" = 2,          
    "allobest_r2" = 2,          
    "allo_minmax_r2" = 2,       
    "hybrid_r2" = 2,            
    "popular_r2" = 2,           
    "popego_r2" = 3,            
    "popego_allo_r2" = 4,       
    "pop_allo_r2" = 3,          
    "pop_allo_neg_r2" = 3,      
    "pop_allo_best_r2" = 3,     
    "pop_allo_bestunw_r2" = 3,  
    "pop_allo_minmax_r2" = 3,   
    "popego_allo_neg_r2" = 4,  
    "popego_allo_best_r2" = 4,  
    "popego_allo_bestunw_r2" = 4 
  )
  if (is.null(model_params[[model_name]])) {
    warning(paste("Unknown model:", model_name))
    return(2)
  }
  
  return(model_params[[model_name]])
}


df_with_fits %>% 
  pivot_longer(c(contains("_r2"), -"max_r2"), names_to = "model", values_to = "R2") %>% 

  
  mutate(best_model_grouped = case_when(
      model %in% c("allo_r2", "allo_neg_r2", "allo_minmax_r2", "allobest_r2") ~ "Allocentric",
      model %in% c("pop_allo_r2", "pop_allo_best_r2", "pop_allo_neg_r2", "pop_allo_bestunw_r2", "pop_allo_minmax_r2") ~ "Popular + Allocentric",
      model %in% c("popego_allo_r2","popego_allo_best_r2", "popego_allo_bestunw_r2", "popego_allo_neg_r2") ~ "Popular + Egocentric + Allocentric",
      model == "popego_r2" ~ "Popular + Egocentric", 
      model == "ego_r2" ~ "Egocentric", 
      model == "popular_r2" ~ "Popular", 
      model == "hybrid_r2" ~ "Allocentric + Egocentric",
      TRUE ~ model  
  )) %>% 
  
  
  mutate(num_params = map_dbl(model, get_num_params)) %>% 
  mutate(aic = r2aic_c(R2, TSS, N, num_params)) %>% 

  group_by(participantID, profile, cos_sim, euc_dist, mae, corr, best_model) %>% 
  mutate(
    delta_aic = aic - min(aic),
    w_aic = exp(-1/2 * delta_aic) / sum(exp(-1/2 * delta_aic)),
    hybrid_waic = sum(if_else(model == "hybrid_r2", w_aic, 0)),
    ego_waic = sum(if_else(model == "ego_r2", w_aic, 0)),
    max_waic = map_dbl(w_aic, max)) %>% 
  
  
  ggplot(aes(x = reorder(participantID, hybrid_waic + ego_waic), y = w_aic, fill = best_model_grouped)) +
  geom_col(position = "stack", width = 0.8) +  # Increase bar width for better visibility
  scale_fill_brewer(palette = "Set2") +  # Use a distinct color palette
  theme_bw() +
  theme(
    axis.text.y = element_text(size = 8),  # Adjust y-axis text size
    axis.text.x = element_blank(),  
    panel.grid = element_blank(), 
    legend.position = "bottom",  
    legend.title = element_text(size = 10, face = "bold"),  
    legend.text = element_text(size = 8)) +  
  labs(x = "Participant ID", y = "AIC Weight", fill = "Model Group") +
  ggtitle("AIC Weight Distribution by Participant ID")

```
```{r}
df_aic_scatter <- df_aic_fit %>%
  mutate(best_model_r2 = case_when(
    best_model == "ego" ~ ego_r2,
    best_model == "allo" ~ allo_r2,
    best_model == "allo_neg" ~ allo_neg_r2,
    best_model == "allobest" ~ allobest_r2,
    best_model == "allominmax" ~ allo_minmax_r2,
    best_model == "hybrid" ~ hybrid_r2,
    best_model == "popular" ~ popular_r2,
    best_model == "popego" ~ popego_r2,
    best_model == "popego_allo" ~ popego_allo_r2,
    best_model == "pop_allo" ~ pop_allo_r2,
    best_model == "pop_allo_neg" ~ pop_allo_neg_r2,
    best_model == "pop_allo_best" ~ pop_allo_best_r2,
    best_model == "pop_allo_bestunw" ~ pop_allo_bestunw_r2,
    best_model == "pop_allo_minmax" ~ pop_allo_minmax_r2,
    best_model == "popego_allo_neg" ~ popego_allo_neg_r2,
    best_model == "popego_allo_best" ~ popego_allo_best_r2,
    best_model == "popego_allo_bestunw" ~ popego_allo_bestunw_r2
  ))
```

```{r}
df_aic_scatter %>%
  group_by(participantID)%>%
  ggplot(mapping = aes(x= corr, y= best_model_r2))+
  geom_point()
```
```{r}
df_aic_scatter <- df_aic_scatter %>%
  mutate(quadrant = case_when(
    corr > 0.3 & best_model_r2 > 0.3 ~ "Good Performance and Good Model Fit",   
    corr > 0.3 & best_model_r2 <= 0.3 ~ "Good Performance and Poor Model Fit", 
    corr <= 0.3 & best_model_r2 > 0.3 ~ "Corr <= 0.5, R2 > 0.5", 
    corr <= 0.3 & best_model_r2 <= 0.3 ~ "Corr <= 0.5, R2 <= 0.5" 
  ))


ggplot(df_aic_scatter, mapping = aes(x = corr, y = best_model_r2, color = quadrant)) +
  geom_point() +
  scale_color_manual(values = c(
    "Corr > 0.5, R2 > 0.5" = "darkgreen",
    "Corr > 0.5, R2 <= 0.5" = "blue",
    "Corr <= 0.5, R2 > 0.5" = "orange",
    "Corr <= 0.5, R2 <= 0.5" = "red"
  )) +
  labs(x = "Correlation (Corr)", y = "Best Model R2", color = "Quadrant") +
  geom_hline(yintercept = 0.3, linetype = "dashed", color = "black") +  
  geom_vline(xintercept = 0.3, linetype = "dashed", color = "black") +  
  theme_minimal()
```

